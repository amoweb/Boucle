#include <windows.h>#include <iostream.h>#include <commctrl.h>#include <mmsystem.h>#include <shlwapi.h>#define MIDI_NOTEON        ((BYTE)0x90)#define MIDI_NOTEOFF       ((BYTE)0x80)#define MIDI_KEYAFTERTOUCH ((BYTE)0xA0)#define MIDI_CTRLCHANGE    ((BYTE)0xB0)#define MIDI_PRGMCHANGE    ((BYTE)0xC0)#define MIDI_CHANPRESS     ((BYTE)0xD0)#define MIDI_PITCHBEND     ((BYTE)0xE0)#define MIDI_META          ((BYTE)0xFF)HMIDIOUT    outHandle;HMIDIIN     inHandle;bool record;bool play;long i;void InfoEvent(DWORD * pdw);const char cstStrNote12[12][4] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};struct note {    long delay;    int note;    int velocity;    char stop;};note loop[10000];int loop_len;int lastNoteTime;void CALLBACK MidiInProc(HMIDIIN hMidiIn,UINT wMsg,DWORD_PTR dwInstance,DWORD_PTR dwParam1,DWORD_PTR dwParam2){    // Relachement d'une note :    if (wMsg == MIM_DATA && (unsigned long)dwParam1!=254 && (unsigned long)dwParam1<25000)    {        int note = dwParam1>>8;        printf("Relache : %s %i\n", cstStrNote12[note%12], (int)(note/12) - 2);        // Enregistre l'arrêt de la note, si on est en mode enregistrement        if(record && note != 96 && note != 97 && note != 98) {            loop[loop_len].note = note;            loop[loop_len].delay = (GetTickCount() - lastNoteTime);            loop[loop_len].stop = true;            loop_len = loop_len + 1;        }        lastNoteTime = GetTickCount();    }    // Appuis d'une note    else if(dwParam1 != 0xfe) {        int note = (dwParam1 >> 8) & 0x00FF;        int velocity = dwParam1 >> 16;        //unsigned long out = 0xx00400090 | (note << 8);        if(note == 97 || note == 98) {            record = !record;            if(record) {                printf("Recording.\n");                loop_len = 0;            }            else {                //On arrête l'enregistrement, on ajoute le delais                loop[loop_len].note = 0;                loop[loop_len].delay = (GetTickCount() - lastNoteTime);                loop_len = loop_len + 1;                printf("end record.\n");                play = true;                printf("Playing.\n");            }        }        else if (note == 96) {            play = !play;            if(play)                printf("Playing.\n");            else                printf("Stop playing\n");            i = 0;            record = false;        }        // Enregistre le début de la note, si on est en mode enregistrement        if(record && note != 96 && note != 97 && note != 98) {            loop[loop_len].note = note;            loop[loop_len].delay = (GetTickCount() - lastNoteTime);            loop[loop_len].stop = false;            loop[loop_len].velocity = velocity;            loop_len = loop_len + 1;        }        lastNoteTime = GetTickCount();        printf("Appuis : %s %i (%d)\n", cstStrNote12[note%12], (int)(note/12) - 2, note);    }}int main() {    unsigned long result;    MIDIHDR midiHdr;    loop_len = 0;    record = false;    play = false;    i = 0;    if (!midiOutOpen(&outHandle, 1, 0, 0, CALLBACK_NULL) ) {        MMRESULT resultat;    }    else        fprintf(stderr,"Midi out error !");    //----------------------------------------------------------------------        //init de la variable globale         //et allocation en memoire d'un buffer         midiHdr.dwFlags =0;         midiHdr.lpData = (char*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 50);         midiHdr.dwBufferLength = 50;        //ouverture du port midi In à l'indice 0       if (!midiInOpen(&inHandle, 0, (DWORD)MidiInProc, 0, CALLBACK_FUNCTION ) ) {           MMRESULT resultatIn;            //preparation du buffer           midiInPrepareHeader(inHandle, &midiHdr, sizeof(MIDIHDR));           //lien entre le port midi In et le buffer pr reception info note           midiInAddBuffer(inHandle, &midiHdr, sizeof(MIDIHDR));           //ecoute du port Midi In           resultatIn = midiInStart(inHandle);            while(true) {                if(play) {                    if(i > loop_len) i = 0;                    unsigned long out;                    // Relachement d'une note :                    if(loop[i].stop)                        out = 0x00000090 | (loop[i].note << 8);                    // Nouvelle note :                    else                        out = 0x00400090 | (loop[i].note << 8);                    // Attend uniquement s'il ne s'agit pas de la première note :                    if(i != 0)                        Sleep(loop[i].delay);                    // Ne joue pas la dernière note (sert à créer un délais):                    if(i < loop_len)                        midiOutShortMsg(outHandle, out);                    i = i + 1;                }                else                    Sleep(1000);                //resultatIn = midiInStart(inHandle);            }       }    //----------------------------------------------------------------------    midiOutClose(outHandle);}